# stdlib
Import something out of the stdlib without knowing where it is.

## Quick Start

Has this ever happened to you?

    >>> import ETree
	ModuleNotFoundError: No module named 'ETree'
	>>> from xml import ETree
	ModuleNotFoundError: No module named 'ETree'
	>>> from xml.etree import ETree
	ModuleNotFoundError: No module named 'ETree'
	>>> from hells heart import stab at thee
	SyntaxError: invalid syntax
	
Well now you can!

    >>> import stdlib
	>>> stdlib.ETree
	<module 'xml.etree.ElementTree' from '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/xml/etree/ElementTree.py'>
	>>> stdlib.ThreadPoolExecutor
	concurrent.futures.thread.ThreadPoolExecutor
	>>> stdlib.IPv4 <tab>
	stdlib.IPv4Address(   stdlib.IPv4Interface( stdlib.IPv4Network(
	>>> stdlib.iloveyou
	AttributeError: iloveyou

See, it loves you too! Try getting *that* from any competing product.

Every name in every module in the standard library--and every name
*of* every module inside every package in the standard library--is now
available in one place.

But wait, there's more!

What happens if you try an ambiguous name?

    >>> stdlib.open
	AttributeError: 'open' is ambiguous: could be 'codecs.open',
	'shelve.open', 'dbm.open', 'gzip.open', 'bz2.open', 'lzma.open',
	'tarfile.open', 'os.open', 'io.open', 'webbrowser.open',
	'aifc.open', 'sunau.open', 'wave.open', 'builtins.open',
	'posix.open'
	
You can see all the possible things you *could* have meant if you
weren't so stupid! Now how much would you pay?

Before you answer: If you act now, you can also see all the
unambiguous names in the standard library:

    >>> dir(stdlib)
    ['A', 'ABC', 'ACCESS_COPY', 'ACCESS_READ', 'ACCESS_WRITE', 'ACK', 
    'ACROSSTOP', 'ADDITEMS', 'AF_APPLETALK', 'AF_DECnet', 'AF_INET6',
	...]

That should come in handy for your daughter's book report on the
Python standard library reference manual!

But that's not all you get!

The `stdlib` code is a useful example of how to use `importlib`, how
to create dynamic attributes, how to backport PEP 562 code to Python
3.6 and earlier, how to create persistent dictionaries, and how to do
really stupid hacks that nobody should ever use.

You can't afford *not* to install `stdlib` today!

Disclaimer: Not for use with Python 2, or Python 3 before 3.4. Ask
your doctor before using after 3.7, as part of the standard library
may be missing. If `stdlib` begins to smoke, seek shelter and cover
head. `from stdlib import *` does nothing useful. Using `stdlib` in
actual code would be very stupid. Do not taunt `stdlib`.

## How to Use

 * Don't.
 
I mean, seriously, using this is probably a terrible idea.

Well, it could actually be handy for screwing around in an interactive
session, so...

At present, you need to create the names database manually for your
favorite version of Python:

    python3 makedb.py

If your favorite version of Python is not named `python3`, feel free
to substitute a different command, but everyone is going to laugh at
you behind your back.
	
Now you need to keep the resulting `names.db` file in the current
working directory in order to use it. 

Since the current working directory could be anywhere, I'd suggest
copying it to every directory on every computer you can get access to
without violating federal law, but that's up to your discretion.

## TODO

In the near future (here defined as somewhere after even your
grandmother is on your current favorite social network, but before
jetpacks and flying cars), `stdlib` should add these features:

 * `setup.py` that creates `names.db` for you at install time.
 * `names.db` looked up via `pkgresources` instead of the cwd.
 * Module list autogenerated from current Python standard library
   (maybe with a bit of hardcoded help) instead of a script that
   runs on the 3.7 docs and then I have to manually edit the result
   and paste it into the source.
 * Hardcode a few more disambiguations--anyone who asks for `Decimal`
   surely means `decimal.Decimal`, not `xmlrpc.client.Decimal`.
 * Hardcode a few more aliases to support things besides `ETree`
   that have weird but common import idioms.
 * Maybe construct `__all__` at import time so `from stdlib import *`
   actually does what you'd expect and fear?
 * Better unit tests.
 * Include some other non-stdlib but very common libraries besides
   `setuptools` if present at install time (`requests`, `bs4`, maybe
   `numpy` and `pandas`?)
 * Make 2.7 work, or just uninstall 2.7 whenever found and force
   people to upgrade because for Guido's sake it's 2018 (or insert
   current year) already.
